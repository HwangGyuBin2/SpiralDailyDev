디자인 패턴의 종류


- 생성 패턴
	- 클라이언트와 클라이언트가 생성해야 하는 객체 인스턴스 사이의 연결을 끊어주는 패턴
	- Singleton, Abstract Factory, Factory Method, Builder, Prototype
- 행동 패턴
	- 클래스, 객체들이 상호작용하는 or 역할을 분담하는 방법을 다루는 패
	- Template Method, State, Itertator, Strategy, Observer, Visitor, Memento, Mediator, Command, Chain of Responsibility
- 구조 패턴
	- 클래스, 객체를 더 큰 구조로 만들 수 있게 구성하는 패턴
	- Decorator, Proxy, Composite, Adapter, Facade, Flyweight, Bridge
- Singleton


> 	정의

> 	생성자가 다수 호출되더라도, 실제로 생성되는 객체는 하나

> 	최초 생성 이후, 생성자 호출 시 생성되어있던 객체를 리턴

> 	static을 통해 최초 한번만 메모리를 할당

> 	주로 사용되는 사례: DB Connection Pool

> 	장점

> 	객체의 유일성 보장

> 	어디에서나 객체 접근 가능

> 	단점

> 	동시성을 고려해야 함

> 	너무 많은 곳에서 해당 데이터를 사용하게 될 경우, 다른 클래스의 간 결합도가 높아짐

> 	관련 키워드

> 	DI, Logger

> 	개인적인 의견

> 	앱 전체적인 곳에서 인스턴스 내부 데이터를 공유해야 하는 상황이 포인트

> 	특히 데이터를 가져오는 동작이 무거울 때

- Adapter


> 	정의

> 	클래스의 인터페이스를 사용자가 기대하는 인터페이스 형태로 적응(변환) 시킵니다. 

> 	서로 일치하지 않는 인터페이스를 갖는 클래스들을 함께 동작시킵니다.

> 	-GoF-

> 	한 클래스의 인터페이스를 클라이언트에서 사용하고자 하는 다른 인터페이스로 변환합니다. 어댑터를 이용하면 인터페이스 호환성 문제 때문에 같이 쓸 수 없는 클래스들을 연결해서 쓸 수 있습니다.

> 	-HFD-

> 	기존에 사용하던 동작(인터페이스)를 변경하지 않고, 새로 이용하고자 하는 동작(인터페이스)를 기존 동작(인터페이스)와 호환되도록 변경

> 	특징

> 	어댑터 패턴은 기존 코드를 재사용하기 위해 내적, 외적 구조를 변환하는 작업을 처리

> 	어댑터 패턴은 기능상 문제없이 동작하는 코드가 단지 인터페이스 차이 때문에 사용할 수 없는 경우 많이 응용

> 	조건

> 	현재 사용하고 있는 라이브러리가 더 이상 요구에 부합하지 않아 재작성하거나, 다른 라이브러리를 사용해야 할 때가 있다. 다른 라이브러리를 사용하는 경우 Adapter 패턴을 이용해 기존 코드를 가능한 적게 변경하면서 새로운 라이브러리로 교체할 수 있다.

> 	기존 버전의 클래스가 다른 인터페이스를 가지도록, 예를 들어 메소드의 파라미터를 변경하거나 반환 값의 타입을 변경해야 한다면? 기존 버전과 새로운 버전의 메소드를 모두 갖는 비대한 클래스를 만들 수도 있을 것이다. 하지만 대부분의 경우 심플한 클래스(새로운 버전)를 만들고 Adapter를 이용하여 새로운 객체가 기존 코드에 존재하는 것처럼 보이게 하는 것이 더 낫다.

> 	>> 

> 	두 클래스가 동일하거나 유사한 작업을 수행하지만 인터페이스가 서로 다른 경우.

> 	두 클래스가 공통 인터페이스를 가지면, 클라이언트 코드가 더 간단하고 명료해질 수 있는 경우.

> 	외부 라이브러리라서 인터페이스를 바꾸고 싶어도 쉽게 바꿀 수 없는 경우, 또는 인터페이스가 프레임워크의 일부라서 이미 많은 클라이언트에서 사용되고 있는 경우, 또는 소스 코드를 갖고 있지 않는 경우.

> 	vs Wrapper

- Template Method


> 	정의

> 	여러 클래스에서 공통으로 사용하는 메서드를 템플릿화해서, 상위 클래스에서 정의하고, 하위 클래스마다 세부 동작 사항을 다르게 구현하는 패턴

> 	변하지 않는 기능(템플릿)은 상위 클래스에 만들어두고 자주 변경되며 확장할 기능은 하위 클래스에서 만들도록 하여, 상위의 메소드 실행 동작 순서는 고정하면서 세부 실행 내용은 다양화 될 수 있는 경우에 사용

> 	조건

> 	클라이언트가 알고리즘의 특정 단계만 확장하고, 전체 알고리즘이나 구조 자체를 확장하진 않을 때

> 	동일한 기능은 상위에서 정의하고, 확장 및 변화가 필요한 부분만 하위 클래스에서 구현할 때 

> 	장점

> 	 클라이언트가 대규모 알고리즘의 특정 부분만 재정의하도록 하여, 알고리즘의 다른 부분에 발생하는 변경 사항의 영향을 덜 받음

> 	상위 추상클래스로 로직을 공통화 하여 코드의 중복이 줄어듬

> 	서브 클래스의 역할을 줄이고, 핵심 로직을 상위 클래스에서 관리하므로서 관리가 용이

> 	헐리우드 원칙 (Hollywood Principle) : 고수준 구성요소에서 저수준을 다루는 원칙 (추상화에 의존)

> 	 단점

> 	 알고리즘의 제공된 골격에 의해 유연성이 제한될 수 있음

> 	알고리즘 구조가 복잡할수록 템플릿 로직 형태를 유지하기 어려움

> 	추상 메소드가 많아지면서 클래스의 생성, 관리가 어려워질 수 있

> 	상위 클래스에서 선언된 추상 메소드를 하위 클래스에서 구현할 때, 그 메소드가 어느 타이밍에서 호출되는지 클래스 로직을 이해해야 할 필요가 있음

> 	로직에 변화가 생겨 상위 클래스를 수정할 때, 모든 서브 클래스의 수정이 필요 할수도 있음

> 	하위 클래스를 통해 기본 단계 구현을 억제하여 리스코프 치환 법칙을 위반할 여지가 있음

- Facade


> 	정의

> 	*하위 시스템을 보다 쉽게 사용할 수 있게 해주는 고급 인터페이스*

> 	다른 커다란 코드 부분에 대한 간략화된 인터페이스를 제공하는 객체

> 	퍼사드는 공통적인 작업에 대해 간편한 메소드들을 제공

> 	조건 

> 	복잡한 서브 시스템에 대해 간단한 인터페이스를 제공할 때

> 	장점

> 	클라이언트 입장에서 서브 시스템을 사용해야 할 때, 다뤄야 할 객체의 수를 줄여준다

> 	클라이언트와 서브 시스템간의 결합도가 높을 때, 활용하여 낮출 수 있음

> 	단점

> 	클라이언트에서 서브 시스템을 직접 사용하는 것을 막을 순 없음

> 	네임스페이스를 사용하는 것이 현실적인 대안

> 	클라이언트에게 제공되는 인터페이스가 변경되면 안 

- Composite
- Strategy
- State
- Interpreter
- Iterator
- Factory Method
- Abastract Factory
- Command
- Memento
- Prototype
- Proxy
- Decorator
- Bridge
- Builder
- Flyweight
- Chain of Responsibility
- Visitor
- Mediator
- Observer

? Helper
